<캐시 기본 동작>
* [cache-control: max-age] 앞서 다룬 쿠키생명주기 헤더처럼 설정이 가능
[그림 8a]
[그림 8b]


<검증 헤더와 조건부 요청 1>
* 기본 캐시헤더 외에 추가로 "검증헤더"를 활용
- 첫요청에 서버응답 [Last-Modified: ~최종수정일 날짜시간~]

* (캐시 시간초과 후) 클라이언트 재요청에 "조건부요청 헤더"
- [if-modified-since: ~가지고있는캐시의 최종수정일~]

* 재요청에 서버응답
ㄴ 상태[304 Not Modified]
ㄴ 헤더[Last-Modified: ~최종수정일 날짜시간~]
ㄴ 바디[~없음~]
- 바디로 받은게 없어도 기존 캐시의 메타정보만 갱신해서 재사용
- 헤더만 통신했으므로 적은 용량만 사용했다


<검증 헤더와 조건부 요청 2>
* 검증 헤더 : 캐시데이터와 서버데이터가 같은지 검증
Last-Modified
ETag

* 조건부 요청 헤더 : 각각 해당 검증헤더를 가진 응답이, 조건에 따라 분기된다
If-Modified-Since
If-None-Match

* 개괄적인 절차
요청 [If-Modified-Since] = 내 캐시에 있는 시간정보 이후로 데이터가 수정됐으면 새로알려줘
응답1 No안바뀜 [304 Not Modified / 바디 미포함] = 헤더만 전송용량을 잡아먹음
응답2 Yes바뀜 [200 OK / 일반적인 모든 데이터 전송] = 헤더+바디 일반적인 전송용량을 가짐

* ETag를 쓰면
- 서버에서 캐시용 데이터에 임의의 버전 이름을 달아둠
ㄴ 해시가 주로 사용됨(?)
ex> ETag: "v1.0"
ex> ETag: "asdhiuobefwlavbuiywqbhjqw"
- 서버에서 데이터가 변경되면 새로운 해시가 매겨지듯 이 이름만 바꿔줌
- Last-Modified 대비, 날짜 대신 해시값만 비교
ex> 01분 : 클라이언트가 받은 캐시용 데이터의 ETag: "aaa"
05분 : 서버에서 데이터가 바뀜 ETag: "bbb"
10분 : 서버에서 데이터가 원래대로 바뀜 ETag: "aaa"
11분 : 클라이언트가 재요청
ㄴ Last-Modified를 썼었다면 갱신날짜가 다르므로 같은 자료임에도 쌩 불러오기
ㄴ ETag 방식을 사용하고, 서버가 캐시데이터들의 버전관리만 잘한다면 용량 절약
 
* 요청 [If-None-Match] = 내 캐시에 있는 해시정보와 다르면 새로알려줘


<캐시와 조건부 요청 헤더>
* 캐시 제어 헤더
[Cache-Control: max-age] 캐시 유효시간을 초단위로
[Cache-Control: no-cache] 데이터를 캐시하되, 항상 ORIGIN 서버에 검증하고 사용