<모든 것이 http>
* 기반 프로토콜
- TCP : http/1.1(주력으로 사용), http/2
- UDP : http/3


<클라이언트-서버 구조>
* Request-Response 구조

* 개별적으로 발전시켜나갈수 있음 : 독립적인 진화
(컴퓨터 → 스마트폰) / (서버 → 성능고도화)


<Stateful, Stateless>
* 무상태 프로토콜(Stateless Protocol)을 지향한다

* (노트북 구매 예시)
- 상태유지 : 클라이언트에 대해 서버가 상태를 가지고 있음 → 중간에 서버가 바뀌면 안된다
ㄴ 서버 하나만 뻑나도, 그게 담당했던 클라이언트 작업이 다 날아간다
- 무상태 : 갑자기 고객, 요청이 증가해도 응답서버를 쉽게 바꿔갈수 있다 → 서버 증설로 쉽게 해결됨
ㄴ 스케일 아웃 (수평 확장)에 유리

* 무상태로 설계할수 없는 경우들이 존재 ex> 로그인
- 브라우저 쿠키, 서버 세션 등을 이용해서, 상태유지를 최소한으로 사용해야한다


<비 연결성(connectionless)>
* 각 요청에 대한 응답만 하고 tcp/ip연결을 끊어버림 : 서버 자원을 최소한으로 유지 가능
- 연결을 새로 맺을때 마다 3 way handshake 소요시간이 생겨버림
- 한번 웹페이지를 띄울때 보면 html, 자바스크립트, css, 이미지 등등 다양한 종류의 자원들을 받아야하는데, 타입별로 끊어가면서 받을순 없겠는거임

* http 지속연결을 사용하게 되며, http2~http3에서 더 많은 최적화가 이루어짐


<http 메시지>
* 구조 : start-line / header / empty line / message body

* 시작라인 : request-line / status-line
- 요청메시지에 request-line : [메서드 SP(공백) 경로 SP http버전 CRLF(엔터)]
- 응답메시지에 status-line : [http버전 상태코드 이유문구]

* 헤더 : [필드명: 필드값] ← 필드명과 기호 사이에 공백을 허용하지 않음!
- http 전송에 필요한 모든 부가정보를 담았다 : 메시지바디의 내용, 크기, 요청클라이언트정보 등등
ㄴ 표준 헤더 너무 많음

* 메시지 바디 : html, 이미지, 영상, json 등등 byte로 표현할수 있는 모든 데이터를 담는다